{"ast":null,"code":"'use strict';\n\nvar _ramda = require('ramda'); // each :: (a -> *), [a]|Object -> undefined\n\n\nvar each = function each(f, x) {\n  return x ? !Array.isArray(x) ? (0, _ramda.forEachObjIndexed)(f, x) : (0, _ramda.forEach)(f, x) : function (x) {\n    return !Array.isArray(x) ? (0, _ramda.forEachObjIndexed)(f, x) : (0, _ramda.forEach)(f, x);\n  };\n}; // reductor :: ((a, b, x) -> a), a, x -> a\n\n\nvar reductor = function reductor(f, a, x) {\n  if (Array.isArray(x)) {\n    return x.reduce(f, a);\n  } else {\n    var acc = a;\n\n    for (var k in x) {\n      acc = f(acc, x[k], k, x);\n    }\n\n    return acc;\n  }\n}; // reduce :: ((a, b, x) -> a) -> a -> x -> a\n// reduce :: ((a, b, x) -> a), a -> x -> a\n// reduce :: ((a, b, x) -> a), a, x -> a\n\n\nvar reduce = function reduce(f, a, x) {\n  return x ? reductor(f, a, x) : a ? function (x) {\n    return reductor(f, a, x);\n  } : function (a, x) {\n    return x ? reductor(f, a, x) : function (x) {\n      return reductor(f, a, x);\n    };\n  };\n}; // filter :: Object -> Object\n\n\nvar filterObjIndexed = function filterObjIndexed(f, x) {\n  return (0, _ramda.compose)((0, _ramda.reduce)(function (acc, k) {\n    acc[k] = x[k];\n    return acc;\n  }, {}), (0, _ramda.filter)(function (k) {\n    return f(x[k], k, x);\n  }), _ramda.keys)(x);\n}; // filter :: Object|[a] -> Object|[a]\n\n\nvar filter = function filter(f, x) {\n  return x ? !Array.isArray(x) ? filterObjIndexed(f, x) : (0, _ramda.filter)(f, x) : function (x) {\n    return !Array.isArray(x) ? filterObjIndexed(f, x) : (0, _ramda.filter)(f, x);\n  };\n}; // tautology :: * -> Bool\n\n\nvar tautology = function tautology() {\n  return true;\n}; // thrower :: string, Error|undefined -> undefined\n\n\nvar thrower = function thrower(msg) {\n  var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;\n  throw new Type(msg);\n};\n\nmodule.exports = {\n  each: each,\n  filter: filter,\n  tautology: tautology,\n  thrower: thrower,\n  R: {\n    compose: _ramda.compose,\n    composeP: _ramda.composeP,\n    map: _ramda.map,\n    mapAccum: _ramda.mapAccum,\n    reduce: reduce,\n    each: each,\n    filter: filter\n  }\n};","map":{"version":3,"sources":["C:/we-transfer-clone/app/node_modules/fs-filesystem/esm/functional.js"],"names":["_ramda","require","each","f","x","Array","isArray","forEachObjIndexed","forEach","reductor","a","reduce","acc","k","filterObjIndexed","compose","filter","keys","tautology","thrower","msg","Type","arguments","length","undefined","Error","module","exports","R","composeP","map","mapAccum"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ramda = require('ramda');\n\n// each :: (a -> *), [a]|Object -> undefined\nvar each = function each(f, x) {\n  return x ? !Array.isArray(x) ? (0, _ramda.forEachObjIndexed)(f, x) : (0, _ramda.forEach)(f, x) : function (x) {\n    return !Array.isArray(x) ? (0, _ramda.forEachObjIndexed)(f, x) : (0, _ramda.forEach)(f, x);\n  };\n};\n\n// reductor :: ((a, b, x) -> a), a, x -> a\nvar reductor = function reductor(f, a, x) {\n  if (Array.isArray(x)) {\n    return x.reduce(f, a);\n  } else {\n    var acc = a;\n    for (var k in x) {\n      acc = f(acc, x[k], k, x);\n    }\n    return acc;\n  }\n};\n\n// reduce :: ((a, b, x) -> a) -> a -> x -> a\n// reduce :: ((a, b, x) -> a), a -> x -> a\n// reduce :: ((a, b, x) -> a), a, x -> a\nvar reduce = function reduce(f, a, x) {\n  return x ? reductor(f, a, x) : a ? function (x) {\n    return reductor(f, a, x);\n  } : function (a, x) {\n    return x ? reductor(f, a, x) : function (x) {\n      return reductor(f, a, x);\n    };\n  };\n};\n\n// filter :: Object -> Object\nvar filterObjIndexed = function filterObjIndexed(f, x) {\n  return (0, _ramda.compose)((0, _ramda.reduce)(function (acc, k) {\n    acc[k] = x[k];return acc;\n  }, {}), (0, _ramda.filter)(function (k) {\n    return f(x[k], k, x);\n  }), _ramda.keys)(x);\n};\n\n// filter :: Object|[a] -> Object|[a]\nvar filter = function filter(f, x) {\n  return x ? !Array.isArray(x) ? filterObjIndexed(f, x) : (0, _ramda.filter)(f, x) : function (x) {\n    return !Array.isArray(x) ? filterObjIndexed(f, x) : (0, _ramda.filter)(f, x);\n  };\n};\n\n// tautology :: * -> Bool\nvar tautology = function tautology() {\n  return true;\n};\n\n// thrower :: string, Error|undefined -> undefined\nvar thrower = function thrower(msg) {\n  var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;\n  throw new Type(msg);\n};\n\nmodule.exports = {\n  each: each,\n  filter: filter,\n  tautology: tautology,\n  thrower: thrower,\n  R: {\n    compose: _ramda.compose,\n    composeP: _ramda.composeP,\n    map: _ramda.map,\n    mapAccum: _ramda.mapAccum,\n    reduce: reduce,\n    each: each,\n    filter: filter\n  }\n};"]},"metadata":{},"sourceType":"script"}