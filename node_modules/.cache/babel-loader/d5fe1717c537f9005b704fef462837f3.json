{"ast":null,"code":"import _arity from './internal/_arity';\nimport _curry2 from './internal/_curry2';\nimport _has from './internal/_has';\n/**\n * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an\n * additional function that will be applied to a given argument set and used to\n * create the cache key under which the results of the function to be memoized\n * will be stored. Care must be taken when implementing key generation to avoid\n * clashes that may overwrite previous entries erroneously.\n *\n *\n * @func\n * @memberOf R\n * @since v0.24.0\n * @category Function\n * @sig (*... -> String) -> (*... -> a) -> (*... -> a)\n * @param {Function} fn The function to generate the cache key.\n * @param {Function} fn The function to memoize.\n * @return {Function} Memoized version of `fn`.\n * @see R.memoize\n * @example\n *\n *      let count = 0;\n *      const factorial = R.memoizeWith(R.identity, n => {\n *        count += 1;\n *        return R.product(R.range(1, n + 1));\n *      });\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      count; //=> 1\n */\n\nvar memoizeWith = /*#__PURE__*/_curry2(function memoizeWith(mFn, fn) {\n  var cache = {};\n  return _arity(fn.length, function () {\n    var key = mFn.apply(this, arguments);\n\n    if (!_has(key, cache)) {\n      cache[key] = fn.apply(this, arguments);\n    }\n\n    return cache[key];\n  });\n});\n\nexport default memoizeWith;","map":{"version":3,"sources":["C:/we-transfer-clone/app/node_modules/ramda/es/memoizeWith.js"],"names":["_arity","_curry2","_has","memoizeWith","mFn","fn","cache","length","key","apply","arguments"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,mBAAnB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,IAAP,MAAiB,iBAAjB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,IAAIC,WAAW,GAAG,aAAaF,OAAO,CAAC,SAASE,WAAT,CAAqBC,GAArB,EAA0BC,EAA1B,EAA8B;AACnE,MAAIC,KAAK,GAAG,EAAZ;AACA,SAAON,MAAM,CAACK,EAAE,CAACE,MAAJ,EAAY,YAAY;AACnC,QAAIC,GAAG,GAAGJ,GAAG,CAACK,KAAJ,CAAU,IAAV,EAAgBC,SAAhB,CAAV;;AACA,QAAI,CAACR,IAAI,CAACM,GAAD,EAAMF,KAAN,CAAT,EAAuB;AACrBA,MAAAA,KAAK,CAACE,GAAD,CAAL,GAAaH,EAAE,CAACI,KAAH,CAAS,IAAT,EAAeC,SAAf,CAAb;AACD;;AACD,WAAOJ,KAAK,CAACE,GAAD,CAAZ;AACD,GANY,CAAb;AAOD,CATqC,CAAtC;;AAUA,eAAeL,WAAf","sourcesContent":["import _arity from './internal/_arity';\nimport _curry2 from './internal/_curry2';\nimport _has from './internal/_has';\n\n/**\n * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an\n * additional function that will be applied to a given argument set and used to\n * create the cache key under which the results of the function to be memoized\n * will be stored. Care must be taken when implementing key generation to avoid\n * clashes that may overwrite previous entries erroneously.\n *\n *\n * @func\n * @memberOf R\n * @since v0.24.0\n * @category Function\n * @sig (*... -> String) -> (*... -> a) -> (*... -> a)\n * @param {Function} fn The function to generate the cache key.\n * @param {Function} fn The function to memoize.\n * @return {Function} Memoized version of `fn`.\n * @see R.memoize\n * @example\n *\n *      let count = 0;\n *      const factorial = R.memoizeWith(R.identity, n => {\n *        count += 1;\n *        return R.product(R.range(1, n + 1));\n *      });\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      count; //=> 1\n */\nvar memoizeWith = /*#__PURE__*/_curry2(function memoizeWith(mFn, fn) {\n  var cache = {};\n  return _arity(fn.length, function () {\n    var key = mFn.apply(this, arguments);\n    if (!_has(key, cache)) {\n      cache[key] = fn.apply(this, arguments);\n    }\n    return cache[key];\n  });\n});\nexport default memoizeWith;"]},"metadata":{},"sourceType":"module"}